import fs from "node:fs";
import path from "node:path";
import { sidebar } from "../src/config/sidebar.mjs";

const BASE_URL = "https://docs.superplane.com";
const DOCS_ROOT = "src/content/docs";
const PUBLIC_DIR = "public";

function ensureDir(dirPath) {
  fs.mkdirSync(dirPath, { recursive: true });
}

function trimQuotes(value) {
  return value.replace(/^['"]|['"]$/g, "");
}

function parseDocFile(filePath) {
  const raw = fs.readFileSync(filePath, "utf8");
  const frontmatter = raw.match(/^---\n([\s\S]*?)\n---\n?/);
  let title = "";
  let description = "";
  let body = raw.trim();

  if (frontmatter) {
    body = raw.slice(frontmatter[0].length).trim();
    for (const line of frontmatter[1].split("\n")) {
      const titleMatch = line.match(/^title:\s*(.*)$/);
      if (titleMatch) title = trimQuotes(titleMatch[1].trim());

      const descriptionMatch = line.match(/^description:\s*(.*)$/);
      if (descriptionMatch) description = trimQuotes(descriptionMatch[1].trim());
    }
  }

  if (!description) {
    description = firstMeaningfulLine(body) || `${title || "Documentation"} page.`;
  }

  return { title, description, body };
}

function firstMeaningfulLine(body) {
  const lines = body.split("\n");
  let inFence = false;
  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed) continue;
    if (trimmed.startsWith("```")) {
      inFence = !inFence;
      continue;
    }
    if (inFence) continue;
    if (trimmed.startsWith("import ")) continue;
    if (trimmed.startsWith("<")) continue;
    if (trimmed.startsWith("#")) continue;
    return trimmed;
  }
  return "";
}

function slugToUrl(slug) {
  return slug === "" ? `${BASE_URL}/` : `${BASE_URL}/${slug}`;
}

function slugToFilePath(slug) {
  const base = slug === "" ? "index" : slug;
  const mdPath = path.join(DOCS_ROOT, `${base}.md`);
  const mdxPath = path.join(DOCS_ROOT, `${base}.mdx`);
  if (fs.existsSync(mdPath)) return mdPath;
  if (fs.existsSync(mdxPath)) return mdxPath;
  throw new Error(`Could not find docs file for slug: "${slug}"`);
}

function resolveManualSections(sidebarConfig) {
  return sidebarConfig
    .filter((section) => Array.isArray(section.items))
    .map((section) => {
      const entries = section.items.map((item) => {
        const filePath = slugToFilePath(item.slug ?? "");
        const parsed = parseDocFile(filePath);
        return {
          label: item.label,
          slug: item.slug ?? "",
          url: slugToUrl(item.slug ?? ""),
          filePath,
          description: parsed.description,
          body: parsed.body,
        };
      });
      return { label: section.label, entries };
    });
}

function resolveAutogeneratedComponents(sidebarConfig) {
  const autogenerated = sidebarConfig.find((section) => section.autogenerate?.directory);
  if (!autogenerated) return null;

  const dir = autogenerated.autogenerate.directory;
  const absolute = path.join(DOCS_ROOT, dir);
  const files = fs
    .readdirSync(absolute)
    .filter((name) => name.endsWith(".md") || name.endsWith(".mdx"))
    .sort((a, b) => a.localeCompare(b));

  const entries = files.map((name) => {
    const filePath = path.join(absolute, name);
    const parsed = parseDocFile(filePath);
    const basename = name.replace(/\.(md|mdx)$/, "");
    const slug = `${dir}/${basename.toLowerCase()}`;

    return {
      label: parsed.title || basename,
      slug,
      url: slugToUrl(slug),
      filePath,
      description: parsed.description,
      body: parsed.body,
    };
  });

  return { label: autogenerated.label, entries };
}

function sectionListLines(section) {
  const lines = [`## ${section.label}`, ""];
  for (const entry of section.entries) {
    lines.push(`- [${entry.label}](${entry.url}): ${entry.description}`);
  }
  lines.push("");
  return lines;
}

function fullSectionLines(section) {
  const lines = [`### ${section.label}`, ""];
  for (const entry of section.entries) {
    lines.push(`#### ${entry.label}`);
    lines.push("");
    lines.push(`Source URL: ${entry.url}`);
    lines.push("");
    lines.push(entry.body);
    lines.push("");
  }
  return lines;
}

function buildLlmsTxt(sections) {
  const lines = [
    "# SuperPlane Docs",
    "",
    "> SuperPlane documentation for building and operating event-driven DevOps workflows.",
    "",
    "This file provides a structured index of documentation pages for LLM-based tools.",
    "",
  ];

  for (const section of sections) {
    lines.push(...sectionListLines(section));
  }

  return `${lines.join("\n").trim()}\n`;
}

function buildLlmsFullTxt(sections) {
  const lines = [
    "# SuperPlane Docs (Full)",
    "",
    "> Comprehensive companion to `/llms.txt` with full page content for the current docs table of contents.",
    "",
    "SuperPlane is an open source DevOps control plane for long-lived, event-driven workflows.",
    "",
  ];

  for (const section of sections) {
    lines.push(...sectionListLines(section));
  }

  lines.push("## Full Content");
  lines.push("");

  for (const section of sections) {
    lines.push(...fullSectionLines(section));
  }

  return `${lines.join("\n").trim()}\n`;
}

function writeOutput(name, content) {
  const outputPath = path.join(PUBLIC_DIR, name);
  fs.writeFileSync(outputPath, content);
  return outputPath;
}

function main() {
  ensureDir(PUBLIC_DIR);

  const sections = resolveManualSections(sidebar);
  const components = resolveAutogeneratedComponents(sidebar);
  if (components) sections.push(components);

  const llms = buildLlmsTxt(sections);
  const llmsFull = buildLlmsFullTxt(sections);

  const llmsPath = writeOutput("llms.txt", llms);
  const llmsFullPath = writeOutput("llms-full.txt", llmsFull);

  console.log(`Generated ${llmsPath}`);
  console.log(`Generated ${llmsFullPath}`);
}

main();
